import { createNitro, prepare, copyPublicAssets, build } from "nitropack";
import { resolve, dirname } from "pathe";
let ssrBundle;
let ssrEntryFile;
function isFullUrl(str) {
  try {
    new URL(str);
    return true;
  } catch {
    return false;
  }
}
function nitroV2Plugin(nitroConfig) {
  let resolvedConfig;
  return [
    {
      name: "tanstack-nitro-v2-vite-plugin",
      generateBundle: {
        handler(_options, bundle) {
          if (this.environment.name !== "ssr") {
            return;
          }
          let entryFile;
          for (const [_name, file] of Object.entries(bundle)) {
            if (file.type === "chunk") {
              if (file.isEntry) {
                if (entryFile !== void 0) {
                  this.error(
                    `Multiple entry points found for service "${this.environment.name}". Only one entry point is allowed.`
                  );
                }
                entryFile = file.fileName;
              }
            }
          }
          if (entryFile === void 0) {
            this.error(
              `No entry point found for service "${this.environment.name}".`
            );
          }
          ssrEntryFile = entryFile;
          ssrBundle = bundle;
        }
      },
      configResolved(config) {
        resolvedConfig = config;
      },
      config(_, env) {
        if (env.command !== "build") {
          return;
        }
        return {
          environments: {
            ssr: {
              consumer: "server",
              build: {
                ssr: true,
                // we don't write to the file system as the below 'capture-output' plugin will
                // capture the output and write it to the virtual file system
                write: false,
                copyPublicDir: false,
                commonjsOptions: {
                  include: [/node_modules/]
                }
              }
            }
          },
          builder: {
            sharedPlugins: true,
            async buildApp(builder) {
              const client = builder.environments.client;
              const server = builder.environments.ssr;
              if (!client) {
                throw new Error("Client environment not found");
              }
              if (!server) {
                throw new Error("SSR environment not found");
              }
              await builder.build(client);
              await builder.build(server);
              const virtualEntry = "#tanstack/start/entry";
              const baseURL = !isFullUrl(resolvedConfig.base) ? resolvedConfig.base : void 0;
              const config = {
                baseURL,
                publicAssets: [
                  {
                    dir: client.config.build.outDir,
                    maxAge: 31536e3,
                    // 1 year
                    baseURL: "/"
                  }
                ],
                ...nitroConfig,
                esbuild: {
                  options: {
                    target: server.config.build.target || void 0,
                    ...nitroConfig?.esbuild?.options
                  }
                },
                renderer: virtualEntry,
                rollupConfig: {
                  ...nitroConfig?.rollupConfig,
                  plugins: [virtualBundlePlugin(ssrBundle)]
                },
                virtual: {
                  ...nitroConfig?.virtual,
                  [virtualEntry]: `import { fromWebHandler } from 'h3'
                                    import handler from '${ssrEntryFile}' 
                                    export default fromWebHandler(handler.fetch)`
                }
              };
              const nitro = await createNitro(config);
              await prepare(nitro);
              await copyPublicAssets(nitro);
              await build(nitro);
              await nitro.close();
            }
          }
        };
      }
    }
  ];
}
function virtualBundlePlugin(bundle) {
  let _modules = null;
  const getModules = () => {
    if (_modules) {
      return _modules;
    }
    _modules = /* @__PURE__ */ new Map();
    for (const [fileName, content] of Object.entries(bundle)) {
      if (content.type === "chunk") {
        const virtualModule = {
          code: content.code,
          map: null
        };
        const maybeMap = bundle[`${fileName}.map`];
        if (maybeMap && maybeMap.type === "asset") {
          virtualModule.map = maybeMap.source;
        }
        _modules.set(fileName, virtualModule);
        _modules.set(resolve(fileName), virtualModule);
      }
    }
    return _modules;
  };
  return {
    name: "virtual-bundle",
    resolveId(id, importer) {
      const modules = getModules();
      if (modules.has(id)) {
        return resolve(id);
      }
      if (importer) {
        const resolved = resolve(dirname(importer), id);
        if (modules.has(resolved)) {
          return resolved;
        }
      }
      return null;
    },
    load(id) {
      const modules = getModules();
      const m = modules.get(id);
      if (!m) {
        return null;
      }
      return m;
    }
  };
}
export {
  nitroV2Plugin
};
//# sourceMappingURL=index.js.map
